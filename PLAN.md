Hi, I'm Rich, a programmer from Europe. I've not been active in the community
before (hence the 'hello'), but I've been using Elm recreationally for a few
months. I'm excited by Elm because I find it easier to divide an application
into conceptual pieces, and avoid cognative overload (compared to javascript).

I'm working on a webapp for managing [Exposure Therapy](ERP) for
people with mental health problems. I'd love to write all of this app in Elm,
but currently I cannot because I want to store data client-side in indexeddb,
for privacy reasons. Since necessity is the mother of invention, I thought
maybe there was an opportunity to contribute to Elm by writing a library to
interface with indexeddb.

I hope that some readers will have a similar interest, and give me some
direction to turn this idea into a project. I'd love to hear your thoughts on
any aspect of this! :)

# IndexedDB API in Elm

The Elm API store is really great. The virtual dom is really easy to use, and
IMO cleaner than jsx. There is good http and websocket support, letting the
user choose how low level their access needs to be.

However, I couldn't find any local storage APIs. These would have to be
whitelisted by the project owner since they need to have a native module. This
means that there would have to be community agreement about the right approach,
rather than the standard evolutionary principle (good packages get used more,
and eventually become de-facto standard).

With that in mind, I want to write up a short description of IndexedDB, how it
relates to Elm, and the possibilities for exploiting Elm's type system and
standard architecture to catch more errors at compile time and give a great
user experience!

My hope is that there is interest elsewhere in the community, and that it is
possible to create a really great API, good enough to be considered for
whitelisting.

## Quick IndexedDB overview.

IndexedDB is a protocol defined in the [Indexed Database API][currentSpec]
document, with an updated version at [Indexed Database API 2.0][draftSpec].
I just give a very high overview here, and these documents always provide the
authoritative source on the workings of the API. I find the [MDN] page useful
as a non-normative guide to the API.

IndexedDb is a collection of databases, each of which is a collection of object
stores, each of which is a collection of values. Each database has a
weak schema, meaning object stores and indexes (see below) are not changeable
during normal operation. Object stores can either use *in-line* keys (where the
key forms part of the value, or *out-of-line* keys, where the key is stored
separately. Keys either must be provided, or are generated by the system. All
of these properties are defined in the schema.

The API follows standard key-value conventions (e.g. get, put) with some extra
functions for iterating over indexes. A difference with key-value stores is
that data in an indexedDB is *ordered* (or equivalently *indexed*), meaning
that there is a natural order to iterate through records, allowing operations
like *get the first 10 records*. Extra indexes can be defined, providing
alternative orderings. These orderings provide the ability to use
fast dividing algorithms (`O(log n)`). For example, the
`IDBObjectStore.openCursor()` api call takes an argument specifying a key
range, and any values outside this range will not be included.

All database changes take place in some kind of `transaction`. In a
transaction, either all changes succeed, or none do. This can avoid
inconsistent state of the database. Transactions can be read-only or
read-write.

Schema changes are managed during a special *upgradeneeded* event. This event
occurs if a database is opened with a version number higher than the current
database version number. A listener for this event can then see both the old
and new version numbers, and make the required changes to the schema, including
adding and deleting objects if necessary, inside a transaction.

## IndexedDB and Elm

The IndexedDB API is quite procedural and definitely asynchronous, so it makes
sense to use the same strategies that are used for http and websocket. The app
can use a `Cmd` to request some data from the database, and a function to
convert the response into a `msg`. Many IndexedDB operations may fail, so the
user must handle this in the `update` function. A function will then generally
have the format `parameters -> Task IdbError out` where `parameters` are the
function call parameters, and `out` is the return value, or `()` if the
function doesn't return (for example a `delete` operation).

It would probably make sense to use the `effect module` functionality, but I
can't say for sure as I don't fully understand it :).

### Prior art

It seems that the only existing repository is located at [github][imbybioRepo].
In this library, functions follow the pattern above (using `Task`s), where the 
error side of the `Result` lets the user know if an error occured in IDB.

If there is an upgrade needed, an Elm function is called with parameters for
the old and new versions, and this function is expected to upgrade the
database.

Other than this, the library thinly wraps IDB with tasks representing
asynchronicity.

### (Potential) Critical path

As I've been writing this article, I've realised that the best approach is
probably first to implement a low-level wrapper round the API using a native
library. After that, it would be possible to allow different abstractions to
compete within pure Elm, without requiring whitelisting native code. Therefor a
possible path would be

 1. Check licensing on the [imbybio][imbybioRepo] repo (I'm not a legal expert).
 2. Finish implementing the repo, lowering
    functionality right down to the native API if there are currently any
    abstractions.
 3. Create a comprehensive test suite and documentation (inc. examples) and
    maybe a full example project.
 4. Look to get the project included in elm-community or similar.

After this, I (or anyone else) could write my own abstractions on top,
experimenting with declarative APIs, or maybe providing a generic storage
framework that could be used with different backends.

I have some existing experimentation at 
[https://github.com/derekdreery/elm-indexeddb](https://github.com/derekdreery/elm-indexeddb).

### Progress notes

I'm not sure I agree with the implementation strategy in imby's version of the
library. There are places where it is easy to exploit the type system to
provide better static guarantees. For example, there is a method called
createObjectStore that is only valid in an upgrade transaction, but this is
not enforced at compile time, and there will be a runtime error if the user
does this.

As an example of an alternative strategy, the database upgrade function could
be required to return a list of operations, that when executed update the
database. This removes the need for methods like createObjectStore above, and
so removes the incorrect code path where this method is called in the wrong
context. It also makes the API more declarative without losing any flexibility.

In my current experimentation, I'm avoiding any declarative abstractions like
the one above if they reduce functionality. At the moment I am trying to
understand transactions: (ignoring errors) A transaction has callbacks for
complete.

#### Update 2

The old scope doesn't really make clear how long a transaction lasts. An
implementation has discretion to end a transaction whenever it wants. However,
reading the new scope yealds

> When a transaction has been started and it can no longer become active, the
> implementation must attempt to commit it, as long as the transaction has not
> been aborted. This usually happens after all requests placed against the
> transaction have been executed and their returned results handled, and no
> new requests have been placed against the transaction.

This suggests that if a transaction is created and loaded with requests, it
will (normally) commit as soon as all those requests have run. Also,

> Transactions are expected to be short lived. This is encouraged by the
> automatic committing functionality described below.

> Authors can still cause transactions to run for a long time; however, this
> usage pattern is not generally recommended as it can lead to a bad user
> experience.

Which offers some justification to encouraging the use of a transaction per
data update.

 [ERP]: https://en.wikipedia.org/wiki/Exposure_therapy
 [currentSpec]: https://www.w3.org/TR/IndexedDB/
 [draftSpec]: https://w3c.github.io/IndexedDB/
 [MDN]: https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API
 [imbybioRepo]: https://github.com/imbybio/elm-indexeddb
